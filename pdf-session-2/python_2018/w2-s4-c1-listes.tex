    \hypertarget{muxe9thodes-spuxe9cifiques-aux-listes}{%
\section{Méthodes spécifiques aux
listes}\label{muxe9thodes-spuxe9cifiques-aux-listes}}

    \hypertarget{compluxe9ment---niveau-basique}{%
\subsection{Complément - niveau
basique}\label{compluxe9ment---niveau-basique}}

    Voici quelques unes des méthodes disponibles sur le type \texttt{list}.

    \hypertarget{trouver-linformation}{%
\subsubsection{Trouver l'information}\label{trouver-linformation}}

    Pour commencer, rappelons comment retrouver la liste des méthodes
définies sur le type \texttt{list}~:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor} }]:} \PY{n}{help}\PY{p}{(}\PY{n+nb}{list}\PY{p}{)}
\end{Verbatim}


    Ignorez les méthodes dont le nom commence et termine par \texttt{\_\_}
(nous parlerons de ceci en semaine 6), vous trouvez alors les méthodes
utiles listées entre \texttt{append} et \texttt{sort}.\\

Certaines de ces méthodes ont été vues dans la vidéo sur les séquences,
c'est le cas notamment de \texttt{count} et \texttt{index}.\\

    Nous allons à présent décrire les autres, partiellement et brièvement.
Un autre complément décrit la méthode \texttt{sort}. Reportez-vous au
lien donné en fin de notebook pour obtenir une information plus
complète.\\

    Donnons-nous pour commencer une liste témoin~:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}1}]:} \PY{n}{liste} \PY{o}{=} \PY{p}{[}\PY{l+m+mi}{0}\PY{p}{,} \PY{l+m+mi}{1}\PY{p}{,} \PY{l+m+mi}{2}\PY{p}{,} \PY{l+m+mi}{3}\PY{p}{]}
        \PY{n+nb}{print}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{liste}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{n}{liste}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
liste [0, 1, 2, 3]

    \end{Verbatim}

    \textbf{Avertissements}~:

\begin{itemize}
\tightlist
\item
  soyez bien attentifs au nombre de fois où vous exécutez les cellules
  de ce notebook~;
\item
  par exemple une liste renversée deux fois peut donner l'impression que
  \texttt{reverse} ne marche pas~;
\item
  n'hésitez pas à utiliser le menu \emph{Cell~-\textgreater{}~Run~All}
  pour réexécuter en une seule fois le notebook entier.
\end{itemize}

    \hypertarget{append}{%
\subsubsection{\texorpdfstring{\texttt{append}}{append}}\label{append}}

    La méthode \texttt{append} permet d'ajouter \textbf{un élément} à la fin
d'une liste~:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}2}]:} \PY{n}{liste}\PY{o}{.}\PY{n}{append}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{ap}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
        \PY{n+nb}{print}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{liste}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{n}{liste}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
liste [0, 1, 2, 3, 'ap']

    \end{Verbatim}

    \hypertarget{extend}{%
\subsubsection{\texorpdfstring{\texttt{extend}}{extend}}\label{extend}}

    La méthode \texttt{extend} réalise la même opération, mais avec
\textbf{tous les éléments} de la liste qu'on lui passe en argument~:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}3}]:} \PY{n}{liste2} \PY{o}{=} \PY{p}{[}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{ex1}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{ex2}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]}
        \PY{n}{liste}\PY{o}{.}\PY{n}{extend}\PY{p}{(}\PY{n}{liste2}\PY{p}{)}
        \PY{n+nb}{print}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{liste}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{n}{liste}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
liste [0, 1, 2, 3, 'ap', 'ex1', 'ex2']

    \end{Verbatim}

    \hypertarget{append-vs}{%
\subsubsection{\texorpdfstring{\texttt{append} \emph{vs}
\texttt{+}}{append vs +}}\label{append-vs}}

    Ces deux méthodes \texttt{append} et \texttt{extend} sont donc assez
voisines~; avant de voir d'autres méthodes de \texttt{list}, prenons un
peu le temps de comparer leur comportement avec l'addition \texttt{+} de
liste. L'élément clé ici, on l'a déjà vu dans la vidéo, est que la liste
est un objet \textbf{mutable}. \texttt{append} et \texttt{extend}
\textbf{modifient} la liste sur laquelle elles travaillent, alors que
l'addition \textbf{crée un nouvel objet}.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}4}]:} \PY{c+c1}{\PYZsh{} pour créer une liste avec les n premiers entiers, on utilise}
        \PY{c+c1}{\PYZsh{} la fonction built\PYZhy{}in range(), que l\PYZsq{}on convertit en liste}
        \PY{c+c1}{\PYZsh{} on aura l\PYZsq{}occasion d\PYZsq{}y revenir}
        \PY{n}{a1} \PY{o}{=} \PY{n+nb}{list}\PY{p}{(}\PY{n+nb}{range}\PY{p}{(}\PY{l+m+mi}{3}\PY{p}{)}\PY{p}{)}
        \PY{n+nb}{print}\PY{p}{(}\PY{n}{a1}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
[0, 1, 2]

    \end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}5}]:} \PY{n}{a2} \PY{o}{=} \PY{n+nb}{list}\PY{p}{(}\PY{n+nb}{range}\PY{p}{(}\PY{l+m+mi}{10}\PY{p}{,} \PY{l+m+mi}{13}\PY{p}{)}\PY{p}{)}
        \PY{n+nb}{print}\PY{p}{(}\PY{n}{a2}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
[10, 11, 12]

    \end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}6}]:} \PY{c+c1}{\PYZsh{} le fait d\PYZsq{}utiliser + crée une nouvelle liste}
        \PY{n}{a3} \PY{o}{=} \PY{n}{a1} \PY{o}{+} \PY{n}{a2}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}7}]:} \PY{c+c1}{\PYZsh{} si bien que maintenant on a trois objets différents}
        \PY{n+nb}{print}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{a1}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{n}{a1}\PY{p}{)}
        \PY{n+nb}{print}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{a2}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{n}{a2}\PY{p}{)}
        \PY{n+nb}{print}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{a3}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{n}{a3}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
a1 [0, 1, 2]
a2 [10, 11, 12]
a3 [0, 1, 2, 10, 11, 12]

    \end{Verbatim}

    Comme on le voit, après une addition, les deux termes de l'addition sont
inchangés. Pour bien comprendre, voyons exactement le même scénario sous
pythontutor~:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor} }]:} \PY{o}{\PYZpc{}}\PY{k}{load\PYZus{}ext} ipythontutor
\end{Verbatim}


    \textbf{Note}~: une fois que vous avez évalué la cellule avec
\texttt{\%\%ipythontutor}, vous devez cliquer sur le bouton
\texttt{Forward} pour voir pas à pas le comportement du programme.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor} }]:} \PY{o}{\PYZpc{}\PYZpc{}}\PY{k}{ipythontutor} height=230 ratio=0.7
        a1 = list(range(3))
        a2 = list(range(10, 13))
        a3 = a1 + a2
\end{Verbatim}


    Alors que si on avait utilisé \texttt{extend}, on aurait obtenu ceci~:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor} }]:} \PY{o}{\PYZpc{}\PYZpc{}}\PY{k}{ipythontutor} height=200 ratio=0.75
        e1 = list(range(3))
        e2 = list(range(10, 13))
        e3 = e1.extend(e2)
\end{Verbatim}


    Ici on tire profit du fait que la liste est un objet mutable~:
\texttt{extend} \textbf{modifie} l'objet sur lequel on l'appelle (ici
\texttt{e1}). Dans ce scénario on ne crée en tout que deux objets, et du
coup il est inutile pour extend de renvoyer quoi que ce soit, et c'est
pourquoi \texttt{e3} ici vaut None.\\

    C'est pour cette raison que~:

\begin{itemize}
\tightlist
\item
  l'addition est disponible sur tous les types séquences - on peut
  toujours réaliser l'addition puisqu'on crée un nouvel objet pour
  stocker le résultat de l'addition~;
\item
  mais \texttt{append} et \texttt{extend} ne sont par exemple
  \textbf{pas disponibles} sur les chaînes de caractères, qui sont
  \textbf{immuables} - si \texttt{e1} était une chaîne, on ne pourrait
  pas la modifier pour lui ajouter des éléments.
\end{itemize}

    \hypertarget{insert}{%
\subsubsection{\texorpdfstring{\texttt{insert}}{insert}}\label{insert}}

    Reprenons notre inventaire des méthodes de \texttt{list}, et pour cela
rappelons nous le contenu de la variable \texttt{liste}~:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}8}]:} \PY{n}{liste}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}8}]:} [0, 1, 2, 3, 'ap', 'ex1', 'ex2']
\end{Verbatim}
            
    La méthode \texttt{insert} permet, comme le nom le suggère, d'insérer un
élément à une certaine position~; comme toujours les indices commencent
à zéro et donc~:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}9}]:} \PY{c+c1}{\PYZsh{} insérer à l\PYZsq{}index 2}
        \PY{n}{liste}\PY{o}{.}\PY{n}{insert}\PY{p}{(}\PY{l+m+mi}{2}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{1 bis}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
        \PY{n+nb}{print}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{liste}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{n}{liste}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
liste [0, 1, '1 bis', 2, 3, 'ap', 'ex1', 'ex2']

    \end{Verbatim}

    On peut remarquer qu'un résultat analogue peut être obtenu avec une
affectation de slice~; par exemple pour insérer au rang 5 (i.e.~avant
\texttt{ap}), on pourrait aussi bien faire~:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}10}]:} \PY{n}{liste}\PY{p}{[}\PY{l+m+mi}{5}\PY{p}{:}\PY{l+m+mi}{5}\PY{p}{]} \PY{o}{=} \PY{p}{[}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{3 bis}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]}
         \PY{n+nb}{print}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{liste}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{n}{liste}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
liste [0, 1, '1 bis', 2, 3, '3 bis', 'ap', 'ex1', 'ex2']

    \end{Verbatim}

    \hypertarget{remove}{%
\subsubsection{\texorpdfstring{\texttt{remove}}{remove}}\label{remove}}

    La méthode \texttt{remove} détruit la \textbf{première occurrence} d'un
objet dans la liste~:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}11}]:} \PY{n}{liste}\PY{o}{.}\PY{n}{remove}\PY{p}{(}\PY{l+m+mi}{3}\PY{p}{)}
         \PY{n+nb}{print}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{liste}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{n}{liste}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
liste [0, 1, '1 bis', 2, '3 bis', 'ap', 'ex1', 'ex2']

    \end{Verbatim}

    \hypertarget{pop}{%
\subsubsection{\texorpdfstring{\texttt{pop}}{pop}}\label{pop}}

    La méthode \texttt{pop} prend en argument un indice~; elle permet
d'extraire l'élément à cet indice. En un seul appel on obtient la valeur
de l'élément et on l'enlève de la liste~:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}12}]:} \PY{n}{popped} \PY{o}{=} \PY{n}{liste}\PY{o}{.}\PY{n}{pop}\PY{p}{(}\PY{l+m+mi}{0}\PY{p}{)}
         \PY{n+nb}{print}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{popped}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{n}{popped}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{liste}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{n}{liste}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
popped 0 liste [1, '1 bis', 2, '3 bis', 'ap', 'ex1', 'ex2']

    \end{Verbatim}

    Si l'indice n'est pas précisé, c'est le dernier élément de la liste qui
est visé~:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}13}]:} \PY{n}{popped} \PY{o}{=} \PY{n}{liste}\PY{o}{.}\PY{n}{pop}\PY{p}{(}\PY{p}{)}
         \PY{n+nb}{print}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{popped}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{n}{popped}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{liste}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{n}{liste}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
popped ex2 liste [1, '1 bis', 2, '3 bis', 'ap', 'ex1']

    \end{Verbatim}

    \hypertarget{reverse}{%
\subsubsection{\texorpdfstring{\texttt{reverse}}{reverse}}\label{reverse}}

    Enfin \texttt{reverse} renverse la liste, le premier élément devient le
dernier~:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}14}]:} \PY{n}{liste}\PY{o}{.}\PY{n}{reverse}\PY{p}{(}\PY{p}{)}
         \PY{n+nb}{print}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{liste}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{n}{liste}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
liste ['ex1', 'ap', '3 bis', 2, '1 bis', 1]

    \end{Verbatim}

    On peut remarquer ici que le résultat se rapproche de ce qu'on peut
obtenir avec une opération de slicing comme ceci~:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}15}]:} \PY{n}{liste2} \PY{o}{=} \PY{n}{liste}\PY{p}{[}\PY{p}{:}\PY{p}{:}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{]}
         \PY{n+nb}{print}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{liste2}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{n}{liste2}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
liste2 [1, '1 bis', 2, '3 bis', 'ap', 'ex1']

    \end{Verbatim}

    \textbf{À la différence toutefois} qu'avec le slicing c'est une copie de
la liste initiale qui est retournée, la liste de départ quant à elle
n'est pas modifiée.

    \hypertarget{pour-en-savoir-plus}{%
\subsubsection{Pour en savoir plus}\label{pour-en-savoir-plus}}

    \href{https://docs.python.org/3/tutorial/datastructures.html\#more-on-lists}{https://docs.python.org/3/tutorial/datastructures.html\#more-on-lists}

    \hypertarget{note-spuxe9cifique-aux-notebooks}{%
\subsubsection{Note spécifique aux
notebooks}\label{note-spuxe9cifique-aux-notebooks}}

    \hypertarget{help-avec}{%
\paragraph{\texorpdfstring{\texttt{help} avec
\texttt{?}}{help avec ?}\\\\}\label{help-avec}}

    Je vous signale en passant que dans un notebook vous pouvez obtenir de
l'aide avec un point d'interrogation \texttt{?} inséré avant ou après un
symbole. Par exemple pour obtenir des précisions sur la méthode
\texttt{list.pop}, on peut faire soit~:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}16}]:} \PY{c+c1}{\PYZsh{} fonctionne dans tous les environnements Python}
         \PY{n}{help}\PY{p}{(}\PY{n+nb}{list}\PY{o}{.}\PY{n}{pop}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
Help on method\_descriptor:

pop({\ldots})
    L.pop([index]) -> item -- remove and return item at index (default last).
    Raises IndexError if list is empty or index is out of range.


    \end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}17}]:} \PY{c+c1}{\PYZsh{} spécifique aux notebooks}
         \PY{c+c1}{\PYZsh{} l\PYZsq{}affichage obtenu est légèrement différent}
         \PY{c+c1}{\PYZsh{} tapez la touche \PYZsq{}Esc\PYZsq{} \PYZhy{} ou cliquez la petite croix}
         \PY{c+c1}{\PYZsh{} pour faire disparaitre le dialogue qui apparaît en bas}
         list.pop\PY{o}{?}
\end{Verbatim}


    \hypertarget{compluxe9tion-avec-tab}{%
\paragraph{\texorpdfstring{Complétion avec
\texttt{Tab}}{Complétion avec Tab}\\\\}\label{compluxe9tion-avec-tab}}

    Dans un notebook vous avez aussi la complétion~; si vous tapez, dans une
cellule de code, le début d'un mot connu dans l'environnement, vous
voyez apparaître un dialogue avec les noms connus qui commencent par ce
mot ici \texttt{li}; utilisez les flèches pour choisir, et `Return' pour
sélectionner.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor} }]:} \PY{c+c1}{\PYZsh{} placez votre curseur à la fin de la ligne après \PYZsq{}li\PYZsq{}}
        \PY{c+c1}{\PYZsh{} et appuyez sur la touche \PYZsq{}Tab\PYZsq{}}
        \PY{n}{li}
\end{Verbatim}