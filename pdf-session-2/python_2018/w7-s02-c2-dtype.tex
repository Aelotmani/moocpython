    
    
    
    

    

    \hypertarget{type-dun-tableau-numpy}{%
\section{\texorpdfstring{Type d'un tableau
\texttt{numpy}}{Type d'un tableau numpy}}\label{type-dun-tableau-numpy}}

    \hypertarget{compluxe9ment---niveau-intermuxe9diaire}{%
\subsection{Complément - niveau
intermédiaire}\label{compluxe9ment---niveau-intermuxe9diaire}}

    Nous allons voir dans ce complément ce qu'il faut savoir sur le type
d'un tableau \texttt{numpy}.

    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{incolor}In [{\color{incolor}1}]:} \PY{k+kn}{import} \PY{n+nn}{numpy} \PY{k}{as} \PY{n+nn}{np}
\end{Verbatim}


    Dans ce complément nous allons rester en dimension 1~:

    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{incolor}In [{\color{incolor}2}]:} \PY{n}{a} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{array}\PY{p}{(}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{,} \PY{l+m+mi}{2}\PY{p}{,} \PY{l+m+mi}{4}\PY{p}{,} \PY{l+m+mi}{8}\PY{p}{]}\PY{p}{)}
\end{Verbatim}


    \hypertarget{toutes-les-cellules-ont-le-muxeame-type}{%
\subsubsection{Toutes les cellules ont le même
type}\label{toutes-les-cellules-ont-le-muxeame-type}}

    Comme on l'a vu dans la vidéo, les très bonnes performances que l'on
peut obtenir en utilisant un tableau \texttt{numpy} sont liées au fait
que le tableau est \textbf{homogène}~: toutes les cellules du tableau
\textbf{possèdent le même type}~:

    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{incolor}In [{\color{incolor}3}]:} \PY{c+c1}{\PYZsh{} pour accéder au type d\PYZsq{}un tableau}
        \PY{n}{a}\PY{o}{.}\PY{n}{dtype}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{outcolor}Out[{\color{outcolor}3}]:} dtype('int64')
\end{Verbatim}
            
    Vous voyez que dans notre cas, le système a choisi pour nous un type
entier~; selon les entrées on peut obtenir~:

    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{incolor}In [{\color{incolor}4}]:} \PY{c+c1}{\PYZsh{} si je mets au moins un flottant}
        \PY{n}{f} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{array}\PY{p}{(}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{,} \PY{l+m+mi}{2}\PY{p}{,} \PY{l+m+mi}{4}\PY{p}{,} \PY{l+m+mf}{8.}\PY{p}{]}\PY{p}{)}
        \PY{n}{f}\PY{o}{.}\PY{n}{dtype}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{outcolor}Out[{\color{outcolor}4}]:} dtype('float64')
\end{Verbatim}
            
    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{incolor}In [{\color{incolor}5}]:} \PY{c+c1}{\PYZsh{} et avec un complexe}
        \PY{n}{c} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{array}\PY{p}{(}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{,} \PY{l+m+mi}{2}\PY{p}{,} \PY{l+m+mi}{4}\PY{p}{,} \PY{l+m+mi}{8}\PY{n}{j}\PY{p}{]}\PY{p}{)}
        \PY{n}{c}\PY{o}{.}\PY{n}{dtype}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{outcolor}Out[{\color{outcolor}5}]:} dtype('complex128')
\end{Verbatim}
            
    Et on peut préciser le type que l'on veut si cette heuristique ne nous
convient pas~:

    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{incolor}In [{\color{incolor}6}]:} \PY{c+c1}{\PYZsh{} je choisis explicitement mon dtype}
        \PY{n}{c2} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{array}\PY{p}{(}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{,} \PY{l+m+mi}{2}\PY{p}{,} \PY{l+m+mi}{4}\PY{p}{,} \PY{l+m+mi}{8}\PY{p}{]}\PY{p}{,} \PY{n}{dtype}\PY{o}{=}\PY{n}{np}\PY{o}{.}\PY{n}{complex64}\PY{p}{)}
        \PY{n}{c2}\PY{o}{.}\PY{n}{dtype}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{outcolor}Out[{\color{outcolor}6}]:} dtype('complex64')
\end{Verbatim}
            
    \hypertarget{pertes-de-pruxe9cision}{%
\subparagraph{Pertes de précision}\label{pertes-de-pruxe9cision}}

    Une fois que le type est déterminé, on s'expose à de possibles pertes de
précision, comme d'habitude~:

    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{incolor}In [{\color{incolor}7}]:} \PY{n}{a}\PY{p}{,} \PY{n}{a}\PY{o}{.}\PY{n}{dtype}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{outcolor}Out[{\color{outcolor}7}]:} (array([1, 2, 4, 8]), dtype('int64'))
\end{Verbatim}
            
    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{incolor}In [{\color{incolor}8}]:} \PY{c+c1}{\PYZsh{} a est de type entier}
        \PY{c+c1}{\PYZsh{} je vais perdre le 0.14}
        \PY{n}{a}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]} \PY{o}{=} \PY{l+m+mf}{3.14}
        \PY{n}{a}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{outcolor}Out[{\color{outcolor}8}]:} array([3, 2, 4, 8])
\end{Verbatim}
            
    \hypertarget{types-disponibles}{%
\subparagraph{Types disponibles}\label{types-disponibles}}

    \href{https://docs.scipy.org/doc/numpy/user/basics.types.html}{Voyez la
liste complète https://docs.scipy.org/doc/numpy/user/basics.types.html}.

Ce qu'il faut en retenir~:

\begin{itemize}
\tightlist
\item
  vous pouvez choisir entre \texttt{bool}, \texttt{int}, \texttt{uint}
  (entier non signé), \texttt{float} et \texttt{complex}~;
\item
  ces types ont diverses tailles pour vous permettre d'optimiser la
  mémoire réellement utilisée~;
\item
  ces types existent en tant que tels (hors de tableaux).
\end{itemize}

    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{incolor}In [{\color{incolor}9}]:} \PY{c+c1}{\PYZsh{} un entier sur 1 seul octet, c\PYZsq{}est possible !}
        \PY{n}{np\PYZus{}1} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{int8}\PY{p}{(}\PY{l+m+mi}{1}\PY{p}{)}
        \PY{c+c1}{\PYZsh{} l\PYZsq{}équivalent en Python natif}
        \PY{n}{py\PYZus{}1} \PY{o}{=} \PY{l+m+mi}{1}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{incolor}In [{\color{incolor}10}]:} \PY{c+c1}{\PYZsh{} il y a bien égalité}
         \PY{n}{np\PYZus{}1} \PY{o}{==} \PY{n}{py\PYZus{}1}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{outcolor}Out[{\color{outcolor}10}]:} True
\end{Verbatim}
            
    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{incolor}In [{\color{incolor}11}]:} \PY{c+c1}{\PYZsh{} mais bien entendu ce ne sont pas les mêmes objets}
         \PY{n}{np\PYZus{}1} \PY{o+ow}{is} \PY{n}{py\PYZus{}1}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{outcolor}Out[{\color{outcolor}11}]:} False
\end{Verbatim}
            
    Du coup, on peut commencer à faire de très substantielles économies de
place~; imaginez que vous souhaitez manipuler une image d'un million de
pixels en noir et blanc sur 256 niveaux de gris~; j'en profite pour vous
montrer \texttt{np.zeros} (qui fait ce que vous pensez)~:

    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{incolor}In [{\color{incolor}12}]:} \PY{c+c1}{\PYZsh{} pur Python}
         \PY{k+kn}{from} \PY{n+nn}{sys} \PY{k}{import} \PY{n}{getsizeof}
         \PY{n}{pure\PYZus{}py} \PY{o}{=} \PY{p}{[}\PY{l+m+mi}{0} \PY{k}{for} \PY{n}{i} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{l+m+mi}{10}\PY{o}{*}\PY{o}{*}\PY{l+m+mi}{6}\PY{p}{)}\PY{p}{]}
         \PY{n}{getsizeof}\PY{p}{(}\PY{n}{pure\PYZus{}py}\PY{p}{)}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{outcolor}Out[{\color{outcolor}12}]:} 8697464
\end{Verbatim}
            
    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{incolor}In [{\color{incolor}13}]:} \PY{c+c1}{\PYZsh{} numpy}
         \PY{n}{num\PYZus{}py} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{zeros}\PY{p}{(}\PY{l+m+mi}{10}\PY{o}{*}\PY{o}{*}\PY{l+m+mi}{6}\PY{p}{,} \PY{n}{dtype}\PY{o}{=}\PY{n}{np}\PY{o}{.}\PY{n}{int8}\PY{p}{)}
         \PY{n}{getsizeof}\PY{p}{(}\PY{n}{num\PYZus{}py}\PY{p}{)}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{outcolor}Out[{\color{outcolor}13}]:} 1000096
\end{Verbatim}
            
    Je vous signale enfin l'attribut \texttt{itemsize} qui vous permet
d'obtenir la taille en octets occupée par chacune des cellules, et qui
correspond donc en gros au nombre qui apparaît dans \texttt{dtype}, mais
divisé par huit~:

    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{incolor}In [{\color{incolor}14}]:} \PY{n}{a}\PY{o}{.}\PY{n}{dtype}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{outcolor}Out[{\color{outcolor}14}]:} dtype('int64')
\end{Verbatim}
            
    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{incolor}In [{\color{incolor}15}]:} \PY{n}{a}\PY{o}{.}\PY{n}{itemsize}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{outcolor}Out[{\color{outcolor}15}]:} 8
\end{Verbatim}
            
    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{incolor}In [{\color{incolor}16}]:} \PY{n}{c}\PY{o}{.}\PY{n}{dtype}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{outcolor}Out[{\color{outcolor}16}]:} dtype('complex128')
\end{Verbatim}
            
    \begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{incolor}In [{\color{incolor}17}]:} \PY{n}{c}\PY{o}{.}\PY{n}{itemsize}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\},frame=single,framerule=0.3mm,rulecolor=\color{cellframecolor}]
{\color{outcolor}Out[{\color{outcolor}17}]:} 16
\end{Verbatim}
            

    % Add a bibliography block to the postdoc
    
    
    
